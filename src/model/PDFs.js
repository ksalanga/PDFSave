import { openDB, ClientDB, update as updateDB, batchUpdate } from './DB'
import { add as addToDeleteStore } from './Deletes'
import { incorrectStringFormat, notBoolean, notNumber } from '../utils/Formatting'
import uniqid from 'uniqid'

var id = uniqid()

/** 
 * PDFs Object Store for the Client Database
 * 
 * description:
 * holds records for all pdfs that are opened through a Chrome based browser.
 * 
 * pdf record in Object Store keys:
 * - primary_key (num) - indexedDB auto generated key.
 * - name (string) - title of the pdf that user can decide.
 * - file_path (string) - absolute file path of the pdf from the chrome url.
 * - current_page (num) - current page that the user is reading or left off at.
 * - length (num) - the length in pages of the pdf.
 * - last_week_latest_page (num) [DEFAULT: 0] - the latest page that the user read last week for reading progress notification purposes.
 * - current_week_latest_page (num) [DEFAULT: 0] - the latest page that the user is currently reading this week for reading progress notification purposes.
 * - bookmarks (list(Bookmark)) - list of bookmark objects (see Bookmark Object keys below).
 * - auto_save_on (boolean) - indicates if this pdf has auto saving on or not.
 * - progress_notification_on (boolean) - turns on reading progress notification for this specific pdf.
 * 
 * !NOTE! Bookmark objects are not their own separate object store that has a many to one relationship with a pdf object store.
 * !NOTE! Their implementation and keys are simple enough that...
 * !NOTE! we can just store them as a list of objects with their own separate ids within pdfs object stores.
 * 
 * Bookmark Object keys:
 * - id (string) - id generated by application.
 * - name (string) - name of bookmark.
 * - page (num) - page that the bookmark of the pdf represents.
 * 
 * Indexes:
 * file_name
 * **/

// const values for pdf record keys that can be updated
export const pdfUpdateKeys = 
{
    name: 'name',
    currentPage: 'current_page',
    lastWeekLatestPage: 'last_week_latest_page',
    currentWeekLatestPage: 'current_week_latest_page',
    bookmarks: 'bookmarks',
    autoSaveOn: 'auto_save_on',
    progressNotificationOn: 'progress_notification_on'
}

// expected keys list that can be updated
// ex: name, current_page, etc.
const expectedPDFUpdateKeys = Object.values(pdfUpdateKeys)

export async function updateName(key, name) {
    try {
        if (incorrectStringFormat(name)) {
            throw 'Error: Incorrect String Format for name'
        }

        const db = await openDB()
        await updateDB(
            db.transaction(ClientDB.pdfStore, 'readwrite').store,
            key,
            pdfUpdateKeys.name,
            name
        )
    } catch(error) {
        console.log(`Something went wrong updating PDF ${key} name`, error)
    }
}

const checkIncorrectPageFormat = (pageNumber, length) => {
    if (notNumber(pageNumber)
    || pageNumber < 0
    || pageNumber > length) {
        throw 'Error: page must be a number between 0 and length of pdf'
    }
}

// function for updating a page number within a PDF whether that's the current page, the last weekly page, or the current weekly page
// the function has built in format checking to throw errors regarding page number
// primaryKey: primary key of pdf record
// updateKey: the key in the pdf record we wish to update
// page: page number (number) value

const updatePage = async (primaryKey, updateKey, page) => {
    try {
        const db = await openDB()
        const pdfStore = db.transaction(ClientDB.pdfStore, 'readwrite').store
        const pdf = pdfStore.get(primaryKey)

        checkIncorrectPageFormat(pdfStore.get(primaryKey), pdf.length)
        
        await updateDB(
            pdfStore,
            primaryKey,
            updateKey,
            page
        )
    } catch(error) {
        console.log(`Something went wrong updating PDF ${primaryKey}'s ${updateKey} page`, error)
    }
}

// function for updating a boolean within a PDF.
// the function has built in format checking to throw errors regarding wrong booleans
// primaryKey: primary key of pdf record
// updateKey: the boolean key we wish to update
// b: boolean value

const updateBoolean = async (primaryKey, updateKey, b) => {
    try {
        if (notBoolean(b)) {
            throw 'updating value must be boolean'
        }
    
        const db = await openDB()
    
        await updateDB(
            db.transaction(ClientDB.pdfStore, 'readwrite').store,
            primaryKey,
            updateKey,
            b
        )
    } catch (error) {
        console.log(`Something went wrong updating PDF ${primaryKey}'s ${updateKey} page`, error)
    }
}

export async function updateCurrentPage(key, currentPage) { await updatePage(key, pdfUpdateKeys.currentPage, currentPage) }
export async function updateLastWeekLatestPage(key, lastWeekLatestPage) { await updatePage(key, pdfUpdateKeys.lastWeekLatestPage, lastWeekLatestPage) }
export async function updateCurrentWeekLatestPage(key, currentWeekLatestPage) { await updatePage(key, pdfUpdateKeys.currentWeekLatestPage, currentWeekLatestPage) }
export async function updateAutoSaveOn(key, autoSaveOn) { updateBoolean(key, pdfUpdateKeys.autoSaveOn, autoSaveOn) }
export async function updateProgressNotificationOn(key, progressNotificationOn) { updateBoolean(key, pdfUpdateKeys.progressNotificationOn, progressNotificationOn) }

export async function updateBookmark(key, id, values) {
}

export var dummyPDF =  
{
    name: `pdf${id}`,
    file_path: `/pdf/pdf${id}.pdf`,
    current_page: 0,
    length: 100,
    last_week_latest_page: 0,
    current_week_latest_page: 0,
    bookmarks: [
        {
            id: '1',
            name: 'Bookmark 1',
            page: 1
        },
    ],
    auto_save_on: true,
    progress_notification_on: false,
}

// TODO (Kenny): Delete dummy PDF array later
export var dummyPDFs = [
    {
        name: 'PDF 1',
        file_path: '/pdf/pdf1.pdf',
        current_page: 24,
        length: 50,
        last_week_latest_page: 0,
        current_week_latest_page: 10,
        bookmarks: [
            {
                id: '1',
                name: 'Bookmark 1',
                page: 1
            },
            {
                id: '2',
                name: 'Bookmark 2',
                page: 2
            },
            {
                id: '3',
                name: 'Bookmark 3',
                page: 3
            },
            {
                id: '4',
                name: 'Bookmark 4',
                page: 4
            },
            {
                id: '5',
                name: 'Bookmark 5',
                page: 5
            },
        ],
        auto_save_on: true,
        progress_notification_on: false
    },
    {
        name: 'PDF 2',
        file_path: '/pdf/pdf2.pdf',
        current_page: 37,
        length: 700,
        last_week_latest_page: 0,
        current_week_latest_page: 0,
        bookmarks: [
            {
                id: '1',
                name: 'Bookmark 1',
                page: 1
            },
            {
                id: '2',
                name: 'Bookmark 2',
                page: 2
            }
        ],
        auto_save_on: true,
        progress_notification_on: false
    },
    {
        name: 'PDF 3',
        file_path: '/pdf/pdf3.pdf',
        current_page: 400,
        length: 1000,
        last_week_latest_page: 120,
        current_week_latest_page: 300,
        bookmarks: [
            {
                id: '1',
                name: 'Bookmark 1',
                page: 1
            }
        ],
        auto_save_on: true,
        progress_notification_on: true
    }
]

// gets pdf with key
export async function getWithKey(key) {
    try {
        const db = await openDB()
        return await db.get(ClientDB.pdfStore, key)    
    } catch (error) {
        console.log(`Something went wrong getting PDF ${key}`)
    }
}

// gets pdf with file name index
export async function getWithFile(file_path) {
    try {
        const db = await openDB()
        return await db.getFromIndex(ClientDB.pdfStore, 'file_path', file_path)
    } catch (error) {
        console.log(`Something went wrong getting PDF in ${file_path}`)
    }
}

// add a PDF to pdfs Object Store
export async function add(
    name,
    filePath,
    length
) {
    try {
        if (incorrectStringFormat(name)) {
            throw 'Error creating PDF: name must be a non empty string'
        }
        if (incorrectStringFormat(filePath)) {
            throw 'Error creating PDF: file path must be a non empty string'
        }
        if (notNumber(length)
        || length < 1) {
            throw 'Error creating PDF: length of pdf must be a number > 0'
        }

        const db = await openDB()

        const pdf =
        {
            name: name,
            file_path: filePath,
            current_page: 0,
            length: length,
            last_week_latest_page: 0,
            current_week_latest_page: 0,
            bookmarks: [],
            auto_save_on: true,
            progress_notification_on: false
        }

        const pdfStore = db.transaction(ClientDB.pdfStore, 'readwrite').store
        
        await pdfStore.add(pdf)
    } catch (error) {
        console.log("Something went wrong adding a PDF", error)
    }
}

// grab a list of all PDFs
export async function getAll() {
    try {
        const db = await openDB()
        const pdfs = []

        let cursor = await db.transaction(ClientDB.pdfStore).store.openCursor()

        while (cursor) {
            pdfs.push({key: cursor.key, ...cursor.value})
            cursor = await cursor.continue()
        }

        return pdfs
    } catch (error) {
        console.log("Something went wrong reading PDFs", error)
    }
}

// update a record of key: key
// with an object of key, value pairs to update
export async function update(key, values) {
    try {
        const db = await openDB()

        const pdfStore = db.transaction(ClientDB.pdfStore, 'readwrite').store

        await batchUpdate(
            pdfStore, 
            key, 
            values, 
            expectedPDFUpdateKeys
        )

    } catch (error) {
        console.log("Something went wrong updating PDF", error)
    }
}

// removes pdf of key: key
export async function remove(key) {
    try {
        const db = await openDB()
        const tx = db.transaction([ClientDB.pdfStore, ClientDB.deleteStore], 'readwrite')

        const pdfStore = tx.objectStore(ClientDB.pdfStore)
        const deleteStore = tx.objectStore(ClientDB.deleteStore)

        // first add pdf's file to delete store
        const pdf = await pdfStore.get(key)
        await addToDeleteStore(pdf.file_path, deleteStore)

        await pdfStore.delete(key)
    } catch (error) {
        console.log("Something went wrong deleting PDF", error)
    }
}